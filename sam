#!/usr/bin/env nu

use std/log

# Reads *.toml recursively and does stuff.
def main [] { }

def 'main list' [
   --config-dir (-c): path = . # full path to config directory
]: nothing -> list {
   build-config $config_dir | columns | sort
}

def 'main show' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> record {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir

   $config | get ($profiles | first) ...($profiles | drop 1)
}

def 'main install' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
]: nothing -> nothing {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   $config.files | each {|file|
      try {
         install-file $file
      } catch {|error|
         $error.rendered | print
      }
   }

   let installed_packages = pacman -Qq | lines

   let std_packages = $config.packages | where {|package|
      $package.from == "std" and $package.ignore == false
   }

   let aur_packages = $config.packages | where {|package|
      $package.from == "aur" and $package.ignore == false
   }

   let local_packages = $config.packages | where {|package|
      $package.from == "lcl" and $package.ignore == false
   }

   (
      install-packages
      $std_packages
      $installed_packages
      "std"

      {|missing_std_packages|
         let missing_std_package_names = $missing_std_packages
         | each {|missing_std_package|
            $missing_std_package.name
         }

         try {
            pacman -S ...$missing_std_package_names
         } catch {|$error|
            $error.rendered | print
         }
      }
   )

   (
      install-packages
      $aur_packages
      $installed_packages
      "aur"

      {|missing_aur_packages|
         let missing_aur_package_names = $missing_aur_packages
         | each {|missing_aur_package|
            $missing_aur_package.name
         }

         try {
            paru -S --aur ...$missing_aur_package_names
         } catch {|$error|
            $error.rendered | print
         }
      }
   )

   (
      install-packages
      $local_packages
      $installed_packages
      "local"

      {|missing_local_packages|
         let missing_local_package_paths = $missing_local_packages
         | each {|missing_local_packages|
            $missing_local_packages.dir_abs_path
         }

         try {
            paru -Bi ...$missing_local_package_paths
         } catch {|$error|
            $error.rendered | print
         }
      }
   )

   #
   # setup services
   #
}

def 'main cleanup' [
   --config-dir (-c): path = . # full path to config directory
   ...profiles: string # list of profile names
] {
   if ($profiles | is-empty) {
      error make {msg: "Missing parameter..."}
   }

   let profiles = $profiles | each {|profile| [$profile] | into cell-path }
   let config = build-config $config_dir
   let config = $config | get ($profiles | first) ...($profiles | drop 1)

   cleanup-packages $config.packages
}

def install-file [file: record] {
   log info (
      $"checking file to install with owner=($file.owner)" +
      $" with target=($file.target_abs_path)"
   )

   let source_abs_path_type = $file.source_abs_path | path type
   let target_abs_path_type = $file.target_abs_path | path type

   match $file.action {
      copy => {
         match [$source_abs_path_type $target_abs_path_type] {
            [null _] => {
               (
                  log
                  error
                  $"skipping source=($file.source_abs_path) does not exist"
               )

               return
            }

            [_ null] => {
               let target_dir_abs_path = $file.target_abs_path | path dirname

               if not ($target_dir_abs_path | path exists) {
                  mkdir $target_dir_abs_path
               }

               log info $"installing to target=($file.target_abs_path)"
               cp -r $file.source_abs_path $file.target_abs_path
            }

            [dir dir] => {
               if (
                  diff -rq $file.target_abs_path $file.source_abs_path
               ) {
                  log info (
                     $"skipping as target=($file.target_abs_path) matches with source"
                  )

                  return
               }

               log info $"installing to target=($file.target_abs_path)"
               rm -r $file.target_abs_path
               cp -r $file.source_abs_path $file.target_abs_path
            }

            [file file] => {
               let target_file = open --raw $file.target_abs_path
               let source_file = open --raw $file.source_abs_path

               if ($target_file == $source_file) {
                  log info (
                     $"skipping as target=($file.target_item_abs_path) matches with source"
                  )

                  return
               }

               log info $"installing to target=($file.target_abs_path)"
               rm $file.target_abs_path
               cp $file.source_abs_path $file.target_abs_path
            }

            [symlink symlink] => {
               if (
                  ($file.source_abs_path | path expand) ==
                  ($file.target_abs_path | path expand)
               ) {
                  log info (
                     $"skipping as target=($file.target_abs_path) matches with source"
                  )

                  return
               }

               log info $"installing to target=($file.target_abs_path)"
               unlink $file.target_abs_path
               cp $file.source_abs_path $file.target_abs_path
            }
         }

         apply-permissions $file.chmod $file.target_abs_path
         apply-ownership $file.owner $file.group $file.target_abs_path
      }

      link => {
         match [$source_abs_path_type $target_abs_path_type] {
            [null _] => {
               (
                  log
                  error
                  $"skipping source=($file.source_abs_path) does not exist"
               )

               return
            }

            [_ null] => {

               let target_parent_dir_abs_path = $file.target_abs_path | path dirname

               if not ($target_parent_dir_abs_path | path exists) {
                  mkdir $target_parent_dir_abs_path
               }

               log info $"installing to target=($file.target_abs_path)"
               ln -s $file.source__abs_path $file.target_abs_path
            }

            [_ dir] => {
               log info $"installing to target=($file.target_abs_path)"
               rm -r $file.target_abs_path
               ln -s $file.source_abs_path $file.target_abs_path
            }

            [_ file] => {
               log info $"installing to target=($file.target_abs_path)"
               rm $file.target_abs_path
               ln -s $file.source_abs_path $file.target_abs_path
            }

            [_ symlink] => {
               if (
                  ($file.target_abs_path | path expand) ==
                  $file.source_abs_path
               ) {
                  log info (
                     $"skipping as target=($file.target_abs_path) matches with source"
                  )

                  return
               }

               log info $"installing to target=($file.target_abs_path)"
               unlink $file.target_abs_path
               ln -s $file.source_abs_path $file.target_abs_path
            }

            [_ _] => {
               log error (
                  $"skipped as not implemented to following action=($file.action)" +
                  $" source=($file.source_abs_path)" +
                  $" target=($file.target_abs_path)"
               )
            }
         }

         apply-ownership $file.owner $file.group $file.target_abs_path
      }

      _ => {
         log error $"skipped as not implemeted for action=($file.action)"
      }
   }
}

def apply-ownership [
   owner: string
   group: string
   target_abs_path: path
]: nothing -> nothing {
   if ($owner == $env.LOGNAME) {
      return
   }

   let target_owner = ls -lD $target_abs_path | get 0 | get user

   if ($target_owner == $owner) {
      return
   }

   chown -R $"($owner):($group)" $target_abs_path
}

# TODO: check before applying though hopefully
# the program itself does the check
def apply-permissions [
   chmod: string
   target_abs_path: path
] {
   chmod $chmod $target_abs_path
}

def install-packages [
   packages
   installed_packages: list<string>
   label: string
   on_install: closure
]: nothing -> nothing {
   log info $"checking ($label) packages to install"

   let missing_packages = $packages | where {|package|
      $package.name not-in $installed_packages
   }

   if ($missing_packages | is-empty) {
      log info $"skipping as there is no ($label) packages to install"
      return
   }

   log info $"installing ($label) packages"
   do $on_install $missing_packages
}

def cleanup-packages [packages] {
   log info 'checking to packages to cleanup'
   let installed_package_names = pacman -Qq | lines
   let package_names = $packages | par-each {|package| $package.name }

   let unlisted_packages_names = $installed_package_names
   | par-each {|installed_package_name|
      if not ($installed_package_name | is-package-a-dependency) {
         if $installed_package_name not-in $package_names {
            $installed_package_name
         }
      }
   }

   if ($unlisted_packages_names | is-not-empty) {
      log info 'cleaning up packages'
      pacman -Rns ...$unlisted_packages_names
   } else {
      log info 'skipping as there is no packages to cleanup'
   }
}

def is-package-a-dependency []: string -> bool {
   let package = $in
   let pactree_output_complete = pactree -rl $package | complete

   if ($pactree_output_complete | get exit_code | $in != 0) {
      return false
   }

   $pactree_output_complete | get stdout | lines | length | $in > 1
}

def build-config [config_dir: path]: nothing -> any {
   let target = $config_dir | path join '*' '**' '*.toml' | into glob

   let config = ls $target
   | get name
   | reduce -f {} {|raw_config_file_rel_path config|
      let raw_config_file_abs_path = $raw_config_file_rel_path | path expand
      let raw_config = open $raw_config_file_abs_path

      let config = do {
         if $raw_config.files? == null {
            return $config
         }

         $raw_config.files
         | reduce -f $config {|raw_file config|
            $raw_file.profiles
            | reduce -f $config {|raw_profile config|
               let files = $config
               | get -o $raw_profile
               | get -o files
               | default []

               let files = $files
               | append {
                  source_abs_path: (
                     $raw_config_file_abs_path | path join $raw_file.source
                  )

                  target_abs_path: $raw_file.target
                  action: $raw_file.action
                  chmod: $raw_file.chmod
                  owner: $raw_file.owner
                  group: $raw_file.group
               }

               $config | upsert ([$raw_profile files] | into cell-path) $files
            }
         }
      }

      let config = do {
         if $raw_config.packages? == null {
            return $config
         }

         $raw_config.packages
         | reduce -f $config {|raw_package config|
            $raw_package.profiles
            | reduce -f $config {|raw_profile config|
               let packages = $config
               | get -o $raw_profile
               | get -o packages
               | default []

               let packages = $packages
               | append (
                  $raw_package.install
                  | each {|package|
                     let path = if $package.path? != null {
                        $raw_config_file_abs_path
                        | path join $package.path
                        | path expand
                     }

                     {
                        from: $package.from
                        name: $package.name
                        ignore: ($package.ignore? | default false)
                        path: $path
                     }
                  }
               )

               $config
               | upsert ([$raw_profile packages] | into cell-path) $packages
            }
         }
      }

      let config = do {
         if $raw_config.units? == null {
            return $config
         }

         $raw_config.units
         | reduce -f $config {|raw_unit config|
            $raw_unit.profiles
            | reduce -f $config {|raw_profile config|
               mut config = $config

               if $raw_unit.enable? != null {
                  let units_to_enable = $config
                  | get -o $raw_profile
                  | get -o units
                  | get -o enable
                  | default []

                  let units_to_enable = $units_to_enable
                  | append $raw_unit.enable

                  $config = $config | upsert ([$raw_profile units enable] | into cell-path) $units_to_enable
               }

               if $raw_unit.mask? != null {
                  let units_to_mask = $config
                  | get -o $raw_profile
                  | get -o units
                  | get -o mask
                  | default []

                  let units_to_mask = $units_to_mask
                  | append $raw_unit.mask

                  $config = $config | upsert ([$raw_profile units mask] | into cell-path) $units_to_mask
               }

               $config
            }
         }
      }

      $config
   }

   $config
}
